<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Fight complexity with complexity</title>
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
<link rel="stylesheet" href="simple.css" />
<style>
  .dark-mode {
    --bg: #212121;
    --accent-bg: #2b2b2b;
    --text: #dcdcdc;
    --text-light: #ababab;
    --accent: #ffb300;
    /*--code: #f06292;*/
    --preformatted: #ccc;
    --disabled: #111;
  }
  .dark-mode img,
  .dark-mode video {
    opacity: 0.8;
  }
  .toggle-theme-btn {
      transform: scale(0.7);
      opacity: 0.4;
      transition: opacity 0.2s;
    }
    .toggle-theme-btn:hover {
      opacity: 0.4;
    }
</style>
<script>
 function toggleDarkMode() {
    const body = document.body;
    body.classList.toggle("dark-mode");
    // Save the user's theme preference to localStorage
    if (body.classList.contains("dark-mode")) {
      localStorage.setItem("theme", "dark");
    } else {
      localStorage.setItem("theme", "light");
    }
  }

  function setDefaultDarkMode() {
    // Retrieve the user's theme preference from localStorage
    const storedTheme = localStorage.getItem("theme");

    // If the stored theme is light, do nothing; otherwise, set it to dark
    if (storedTheme !== "light") {
      document.body.classList.add("dark-mode");
    }
  }

  // Set the default mode to dark when the DOM is fully loaded
  document.addEventListener('DOMContentLoaded', setDefaultDarkMode);
</script>
</head>
<body>
<div id="preamble" class="status">
<div style="position: fixed; top: 10px; right: 10px;">
         <button class="toggle-theme-btn" onclick="toggleDarkMode()">Light/Dark</button>
       </div>
</div>
<div id="content" class="content">
<h1 class="title">Fight complexity with complexity</h1>
<p>
<a href="./index.html">Home</a>
</p>

<hr />
<p>
<i>The Sage sees without looking, finds without searching, and arrives without going anywhere.</i>
</p>

<p>
Lao Tzu, <i>Tao Te Ching</i>
</p>
<hr />

<p>
When I joined my thesis lab in 2012, we were working with a new kind of "big data" from a new kind of single-cell technology. The data were not human-readable. Think of an excel sheet of 50 columns by 100,000+ rows. As such, many methods were developed around sub-setting and visualizing the data, so humans could actually read this. One class of these methods is non-linear dimensionality reduction, like t-SNE and UMAP. These are black box algorithms. Their output can give us high-level intuition of what's there. But it's hard to interpret how accurate they are in relation to how accurate we think they are, given that <a href="./the_beauty_is_truth_delusion.html">they look very nice</a>. The way I approached this problem was to <a href="./drfz_tsne_interrogation_talk_final.pdf">use the algorithm itself</a> to try to explain the algorithm's accuracy, by coloring and <a href="https://github.com/tjburns08/knn_sleepwalk">labeling</a> these maps by their own performance. I was using a black box algorithm to explain a black box algorithm. I was using complexity (t-SNE and UMAP) to interpret complexity (t-SNE and UMAP).
</p>

<p>
Fast forward to 2023. ChatGPT has brought forth an interest in (and fear of) AI that we have never seen before. But there is something interesting happening here that is relevant to this article. These language models are black box algorithms. We have intuition from an input and output perspective of what's going on, but we can't explain what's going on at the neuron to neuron level. But OpenAI is now experimenting with using GPT models to explain the neurons of GPT models. Specifically, it's using <a href="https://openai.com/research/language-models-can-explain-neurons-in-language-models">GPT-4 to interpret GPT-2</a>. While I can't evaluate the merit of this approach at this time, it points to the same theme: using complexity (GPT-4) to interpret complexity (GPT-2).
</p>

<p>
Now let's look at the human brain. When I was in undergrad learning basic neuroscience as part of my major, I learned about the grandmother neuron hypothesis. This was the idea that there would be a group of neurons that fired when I saw my grandma, and a smaller group of neurons that fired when she was in a rocking chair. And eventually a single neuron that would be associated with grandma in the rocking chair at a particular angle. This hypothesis turned out to be wrong. The cortex stores information in a decentralized manner. Ablating a piece of the cortex doesn't ablate a specific childhood memory, because that memory is stored all over. At this point, the undergrad version of me got the idea that the human brain was irreducibly complex. The idea that we could put on a helmet that would interpret our thoughts was science fiction and that's that.
</p>

<p>
Enter GPT based language models. Again, a series of studies I can't perfectly evaluate the merit of just yet, but we have a GPT-based language model <a href="https://www.biorxiv.org/content/10.1101/2022.09.29.509744v1">converting fMRI data into interpretable words</a> associated with what the subject was seeing. A similar study out of Cold Spring Harbor used an AI diffusion model (image generator) to <a href="https://www.biorxiv.org/content/10.1101/2022.11.18.517004v1">reconstruct images</a> that the subject was perceiving using fMRI data. Now, I've been doing biology long enough that I will approach this kind of work with a healthy level of skepticism for a few years, but we're dealing with a similar theme as before: using complexity (AI models) to interpret complexity (the human brain).
</p>

<p>
Now let's shift from computation, my second love, to wet-lab biology, my first love. At the start of graduate school, in the early 2010s, the trendy thing was to use systems biology to finally understand biology well enough that we can develop individualized cocktails of drugs for cancer patients depending on the exact nature of their tumor. I joined a systems immunology lab as a cancer biology PhD student, thinking that we'd be able to de-code biological networks both in normal and cancerous tissue enough to make this a reality. While it turns out that <a href="./its_more_complicated_than_that.html">it's more complicated than that</a>, what did happen was a revolution in cancer immunotherapy: CAR T cells.
</p>

<p>
The idea here is that the immune system leverages its own complexity to fight the complexity of the rapidly evolving world of pathogens in our environment. So why not train the immune system to recognize and fight cancer? It's not a new idea, but unlike AI, ideas in biology take a long time to develop. CAR T cell therapy is one great example of how you might get it done. You take the patient's T cells, add an antigen to them that targets the cancer, and reintroduce these engineered T cells back into the patient.
</p>

<p>
But notice the philosophical difference between this approach and the targeted therapy approach. Targeted therapy contained this embedded mental model that we would have a perfect molecular wiring diagram of a cancer patient on a computer, and we would be able to use all kinds of <i>in-silico</i> modeling tools to figure out what drugs were needed, and generate the cocktail of drugs, curing the cancer. CAR T cell therapy contains an embedded mental model that biology is complicated, cancer is complicated, and the complicated immune system handles the complicated pathogenic world pretty well, so let's fight a cancer's complexity with the immune system's complexity. In a way, cancer immunotherapy contains an embedded admission of ignorance, which in my opinion is a good thing. Because that is what science is.
</p>

<p>
I'll conclude by re-introducing a word into the biological lexicon that I hear largely from sustainability research: <a href="https://consilienceproject.org/challenges-to-making-sense-of-the-21st-century/">hyperobjects</a>. A hyperobject is a high-dimensional shape and/or cloud and/or network and/or data structure that we cannot possibly perceive all at once. One prototypical example of this is the ocean. When I think about the ocean, I think about a big vast blue body of water, the setting sun, the sound of the waves, and light surf rock music (in case you wanted to know about my hobbies in grad school). But in reality, the ocean is a huge network of the chemical properties of the seawater, its interaction with the dynamics single-cell and multi-cell life, sunlight, gas exchange with the atmosphere, geothermal vents, coral reefs, ocean currents, and of course, all of this interacting with human pollutants.
</p>

<p>
How do you understand a hyperobject? You can't. But what you can do is slice it in as many ways as you can until you get some intuition around it, while acknoledging that your intution around it will be incomplete. Examples of this range from creating Hegelian dialectics between opposing views rather than taking a side, to studying something like the ocean from as many different angles as you can. To admit that something is a hyperobject is to admit one's ignorance. But it's not just that. The subtletly here is that the admission of a hyperobject is a call to action. It tells you that it's time to start peering into slices of that hyperobject so you can start to get actionable intution around it (eg. stop polluting the ocean).
</p>

<p>
But the advent of the "fight complexity with complexity" paradigm gives us a new approach. You get another hyperobject to grok the hyperobject in question, and then tell the human what it needs to know. When we have an AI model that can synthesize all possible ways a protein can fold with every study and dataset ever published about cell signaling, will we be able to re-visit the old dream of targeted therapy? Maybe. If not, then maybe we can get really good at tweaking the immune system to work in our favor. Either way, "fight complexity with complexity" is worth thinking about, because this wave isn't dying down any time soon.
</p>
</div>
<div id="postamble" class="status">
<p class="date">Date: May 16, 2023 - May 16, 2023</p>
<p class="creator"><a href="https://www.gnu.org/software/emacs/">Emacs</a> 28.1 (<a href="https://orgmode.org">Org</a> mode 9.5.2)</p>
</div>
</body>
</html>
